"""
Git Integration for Attack Detection Auto-Remediation

This module provides git operations for automatically creating pull requests
with security fixes generated by the remediation engine.

Features:
- Branch creation for fix recommendations
- Patch application to codebase
- Commit with descriptive security-focused messages
- PR creation via GitHub CLI or API
- PR status tracking and updates
"""

import asyncio
import logging
import os
import re
import subprocess
import tempfile
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Tuple

logger = logging.getLogger(__name__)


class PRStatus(Enum):
    """Pull request status."""
    DRAFT = "draft"
    OPEN = "open"
    MERGED = "merged"
    CLOSED = "closed"
    PENDING = "pending"
    FAILED = "failed"


class GitOperationError(Exception):
    """Error during git operation."""
    pass


class PRCreationError(Exception):
    """Error creating pull request."""
    pass


@dataclass
class BranchInfo:
    """Information about a git branch."""
    name: str
    base_branch: str
    created_at: datetime
    commit_sha: Optional[str] = None
    is_remote: bool = False

    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.utcnow()


@dataclass
class CommitInfo:
    """Information about a git commit."""
    sha: str
    message: str
    author: str
    timestamp: datetime
    files_changed: List[str] = field(default_factory=list)


@dataclass
class PullRequestInfo:
    """Information about a pull request."""
    number: int
    title: str
    body: str
    branch: str
    base_branch: str
    status: PRStatus
    url: str
    created_at: datetime
    attack_id: Optional[str] = None
    recommendation_id: Optional[str] = None
    labels: List[str] = field(default_factory=list)
    reviewers: List[str] = field(default_factory=list)


@dataclass
class PatchApplication:
    """Result of applying a patch."""
    success: bool
    files_modified: List[str]
    files_created: List[str]
    files_deleted: List[str]
    error_message: Optional[str] = None
    conflicts: List[str] = field(default_factory=list)


class GitProvider(ABC):
    """Abstract git provider interface."""

    @abstractmethod
    async def create_branch(
        self,
        branch_name: str,
        base_branch: str = "main",
    ) -> BranchInfo:
        """Create a new branch."""
        pass

    @abstractmethod
    async def switch_branch(self, branch_name: str) -> bool:
        """Switch to a branch."""
        pass

    @abstractmethod
    async def commit_changes(
        self,
        message: str,
        files: Optional[List[str]] = None,
    ) -> CommitInfo:
        """Commit staged changes."""
        pass

    @abstractmethod
    async def push_branch(
        self,
        branch_name: str,
        force: bool = False,
    ) -> bool:
        """Push branch to remote."""
        pass

    @abstractmethod
    async def create_pull_request(
        self,
        title: str,
        body: str,
        branch: str,
        base_branch: str = "main",
        draft: bool = False,
        labels: Optional[List[str]] = None,
        reviewers: Optional[List[str]] = None,
    ) -> PullRequestInfo:
        """Create a pull request."""
        pass

    @abstractmethod
    async def get_pull_request(
        self,
        pr_number: int,
    ) -> Optional[PullRequestInfo]:
        """Get pull request information."""
        pass

    @abstractmethod
    async def update_pull_request(
        self,
        pr_number: int,
        title: Optional[str] = None,
        body: Optional[str] = None,
        labels: Optional[List[str]] = None,
    ) -> PullRequestInfo:
        """Update a pull request."""
        pass


class LocalGitProvider(GitProvider):
    """Git provider using local git commands."""

    def __init__(
        self,
        repo_path: str,
        remote: str = "origin",
    ):
        self.repo_path = Path(repo_path)
        self.remote = remote
        self._validate_repo()

    def _validate_repo(self):
        """Validate that path is a git repository."""
        git_dir = self.repo_path / ".git"
        if not git_dir.exists():
            raise GitOperationError(
                f"Not a git repository: {self.repo_path}"
            )

    async def _run_git(
        self,
        *args: str,
        check: bool = True,
    ) -> Tuple[int, str, str]:
        """Run a git command."""
        cmd = ["git", "-C", str(self.repo_path)] + list(args)

        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, stderr = await process.communicate()

            stdout_str = stdout.decode("utf-8").strip()
            stderr_str = stderr.decode("utf-8").strip()

            if check and process.returncode != 0:
                raise GitOperationError(
                    f"Git command failed: {' '.join(args)}\n{stderr_str}"
                )

            return process.returncode, stdout_str, stderr_str

        except FileNotFoundError:
            raise GitOperationError("Git is not installed or not in PATH")

    async def create_branch(
        self,
        branch_name: str,
        base_branch: str = "main",
    ) -> BranchInfo:
        """Create a new branch from base."""
        # Fetch latest from remote
        await self._run_git("fetch", self.remote, base_branch, check=False)

        # Create branch from remote base
        remote_base = f"{self.remote}/{base_branch}"
        await self._run_git("checkout", "-b", branch_name, remote_base)

        # Get commit SHA
        _, sha, _ = await self._run_git("rev-parse", "HEAD")

        return BranchInfo(
            name=branch_name,
            base_branch=base_branch,
            created_at=datetime.utcnow(),
            commit_sha=sha,
            is_remote=False,
        )

    async def switch_branch(self, branch_name: str) -> bool:
        """Switch to existing branch."""
        returncode, _, _ = await self._run_git(
            "checkout", branch_name, check=False
        )
        return returncode == 0

    async def commit_changes(
        self,
        message: str,
        files: Optional[List[str]] = None,
    ) -> CommitInfo:
        """Commit changes."""
        # Stage files
        if files:
            for file in files:
                await self._run_git("add", file)
        else:
            await self._run_git("add", "-A")

        # Commit
        await self._run_git("commit", "-m", message)

        # Get commit info
        _, sha, _ = await self._run_git("rev-parse", "HEAD")
        _, author, _ = await self._run_git(
            "log", "-1", "--format=%an <%ae>"
        )
        _, timestamp_str, _ = await self._run_git(
            "log", "-1", "--format=%aI"
        )
        _, files_str, _ = await self._run_git(
            "diff-tree", "--no-commit-id", "--name-only", "-r", "HEAD"
        )

        return CommitInfo(
            sha=sha,
            message=message,
            author=author,
            timestamp=datetime.fromisoformat(timestamp_str.replace("Z", "+00:00")),
            files_changed=files_str.split("\n") if files_str else [],
        )

    async def push_branch(
        self,
        branch_name: str,
        force: bool = False,
    ) -> bool:
        """Push branch to remote."""
        args = ["push", "-u", self.remote, branch_name]
        if force:
            args.insert(1, "--force")

        returncode, _, _ = await self._run_git(*args, check=False)
        return returncode == 0

    async def create_pull_request(
        self,
        title: str,
        body: str,
        branch: str,
        base_branch: str = "main",
        draft: bool = False,
        labels: Optional[List[str]] = None,
        reviewers: Optional[List[str]] = None,
    ) -> PullRequestInfo:
        """Create PR using GitHub CLI."""
        args = [
            "pr", "create",
            "--title", title,
            "--body", body,
            "--base", base_branch,
            "--head", branch,
        ]

        if draft:
            args.append("--draft")

        if labels:
            for label in labels:
                args.extend(["--label", label])

        if reviewers:
            for reviewer in reviewers:
                args.extend(["--reviewer", reviewer])

        try:
            returncode, stdout, stderr = await self._run_gh(*args)

            if returncode != 0:
                raise PRCreationError(f"Failed to create PR: {stderr}")

            # Parse PR URL from output
            pr_url = stdout.strip()
            pr_number = int(pr_url.split("/")[-1])

            return PullRequestInfo(
                number=pr_number,
                title=title,
                body=body,
                branch=branch,
                base_branch=base_branch,
                status=PRStatus.DRAFT if draft else PRStatus.OPEN,
                url=pr_url,
                created_at=datetime.utcnow(),
                labels=labels or [],
                reviewers=reviewers or [],
            )

        except FileNotFoundError:
            raise PRCreationError(
                "GitHub CLI (gh) is not installed. "
                "Install from: https://cli.github.com/"
            )

    async def _run_gh(
        self,
        *args: str,
    ) -> Tuple[int, str, str]:
        """Run a GitHub CLI command."""
        cmd = ["gh", "-C", str(self.repo_path)] + list(args)

        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await process.communicate()

        return (
            process.returncode,
            stdout.decode("utf-8").strip(),
            stderr.decode("utf-8").strip(),
        )

    async def get_pull_request(
        self,
        pr_number: int,
    ) -> Optional[PullRequestInfo]:
        """Get PR info using GitHub CLI."""
        returncode, stdout, _ = await self._run_gh(
            "pr", "view", str(pr_number), "--json",
            "number,title,body,headRefName,baseRefName,state,url,createdAt,labels,reviewRequests"
        )

        if returncode != 0:
            return None

        import json
        data = json.loads(stdout)

        status_map = {
            "OPEN": PRStatus.OPEN,
            "CLOSED": PRStatus.CLOSED,
            "MERGED": PRStatus.MERGED,
        }

        return PullRequestInfo(
            number=data["number"],
            title=data["title"],
            body=data["body"],
            branch=data["headRefName"],
            base_branch=data["baseRefName"],
            status=status_map.get(data["state"], PRStatus.OPEN),
            url=data["url"],
            created_at=datetime.fromisoformat(
                data["createdAt"].replace("Z", "+00:00")
            ),
            labels=[l["name"] for l in data.get("labels", [])],
            reviewers=[r["login"] for r in data.get("reviewRequests", [])],
        )

    async def update_pull_request(
        self,
        pr_number: int,
        title: Optional[str] = None,
        body: Optional[str] = None,
        labels: Optional[List[str]] = None,
    ) -> PullRequestInfo:
        """Update PR using GitHub CLI."""
        args = ["pr", "edit", str(pr_number)]

        if title:
            args.extend(["--title", title])
        if body:
            args.extend(["--body", body])
        if labels:
            args.extend(["--add-label", ",".join(labels)])

        await self._run_gh(*args)

        pr_info = await self.get_pull_request(pr_number)
        if not pr_info:
            raise PRCreationError(f"Failed to get updated PR: {pr_number}")

        return pr_info


class MockGitProvider(GitProvider):
    """Mock git provider for testing."""

    def __init__(self):
        self.branches: Dict[str, BranchInfo] = {}
        self.commits: List[CommitInfo] = []
        self.pull_requests: Dict[int, PullRequestInfo] = {}
        self._current_branch = "main"
        self._pr_counter = 1

    async def create_branch(
        self,
        branch_name: str,
        base_branch: str = "main",
    ) -> BranchInfo:
        branch = BranchInfo(
            name=branch_name,
            base_branch=base_branch,
            created_at=datetime.utcnow(),
            commit_sha=f"mock_{branch_name}_sha",
        )
        self.branches[branch_name] = branch
        self._current_branch = branch_name
        return branch

    async def switch_branch(self, branch_name: str) -> bool:
        if branch_name in self.branches or branch_name == "main":
            self._current_branch = branch_name
            return True
        return False

    async def commit_changes(
        self,
        message: str,
        files: Optional[List[str]] = None,
    ) -> CommitInfo:
        commit = CommitInfo(
            sha=f"mock_commit_{len(self.commits)}",
            message=message,
            author="Agent Smith <smith@agent-os.local>",
            timestamp=datetime.utcnow(),
            files_changed=files or [],
        )
        self.commits.append(commit)
        return commit

    async def push_branch(
        self,
        branch_name: str,
        force: bool = False,
    ) -> bool:
        if branch_name in self.branches:
            self.branches[branch_name].is_remote = True
            return True
        return False

    async def create_pull_request(
        self,
        title: str,
        body: str,
        branch: str,
        base_branch: str = "main",
        draft: bool = False,
        labels: Optional[List[str]] = None,
        reviewers: Optional[List[str]] = None,
    ) -> PullRequestInfo:
        pr_number = self._pr_counter
        self._pr_counter += 1

        pr = PullRequestInfo(
            number=pr_number,
            title=title,
            body=body,
            branch=branch,
            base_branch=base_branch,
            status=PRStatus.DRAFT if draft else PRStatus.OPEN,
            url=f"https://github.com/mock/repo/pull/{pr_number}",
            created_at=datetime.utcnow(),
            labels=labels or [],
            reviewers=reviewers or [],
        )
        self.pull_requests[pr_number] = pr
        return pr

    async def get_pull_request(
        self,
        pr_number: int,
    ) -> Optional[PullRequestInfo]:
        return self.pull_requests.get(pr_number)

    async def update_pull_request(
        self,
        pr_number: int,
        title: Optional[str] = None,
        body: Optional[str] = None,
        labels: Optional[List[str]] = None,
    ) -> PullRequestInfo:
        pr = self.pull_requests.get(pr_number)
        if not pr:
            raise PRCreationError(f"PR not found: {pr_number}")

        if title:
            pr.title = title
        if body:
            pr.body = body
        if labels:
            pr.labels.extend(labels)

        return pr


class PatchApplicator:
    """Applies patches to the codebase."""

    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path)

    def apply_patch(
        self,
        patch_content: str,
        file_path: str,
    ) -> PatchApplication:
        """Apply a patch to a file."""
        full_path = self.repo_path / file_path
        files_modified = []
        files_created = []

        try:
            if full_path.exists():
                # Read existing content
                original_content = full_path.read_text()

                # Apply patch (simple replacement for now)
                new_content = self._apply_diff(original_content, patch_content)

                if new_content != original_content:
                    full_path.write_text(new_content)
                    files_modified.append(file_path)
            else:
                # Create new file
                full_path.parent.mkdir(parents=True, exist_ok=True)
                full_path.write_text(patch_content)
                files_created.append(file_path)

            return PatchApplication(
                success=True,
                files_modified=files_modified,
                files_created=files_created,
                files_deleted=[],
            )

        except Exception as e:
            return PatchApplication(
                success=False,
                files_modified=[],
                files_created=[],
                files_deleted=[],
                error_message=str(e),
            )

    def apply_unified_diff(
        self,
        diff_content: str,
    ) -> PatchApplication:
        """Apply a unified diff patch."""
        files_modified = []
        files_created = []
        files_deleted = []
        conflicts = []

        try:
            # Parse unified diff
            current_file = None
            hunks = []

            for line in diff_content.split("\n"):
                if line.startswith("--- "):
                    pass  # Old file indicator
                elif line.startswith("+++ "):
                    # New file path
                    match = re.match(r"\+\+\+ [ab]/(.+)", line)
                    if match:
                        if current_file and hunks:
                            self._apply_hunks(current_file, hunks)
                            files_modified.append(current_file)
                        current_file = match.group(1)
                        hunks = []
                elif line.startswith("@@"):
                    # Hunk header
                    hunks.append({"header": line, "lines": []})
                elif hunks:
                    hunks[-1]["lines"].append(line)

            # Apply last file
            if current_file and hunks:
                self._apply_hunks(current_file, hunks)
                files_modified.append(current_file)

            return PatchApplication(
                success=True,
                files_modified=files_modified,
                files_created=files_created,
                files_deleted=files_deleted,
            )

        except Exception as e:
            return PatchApplication(
                success=False,
                files_modified=files_modified,
                files_created=files_created,
                files_deleted=files_deleted,
                error_message=str(e),
                conflicts=conflicts,
            )

    def _apply_diff(self, original: str, patch: str) -> str:
        """Apply a simple diff/replacement."""
        # For now, if patch looks like full content, use it directly
        # In production, this would use proper diff parsing
        if patch.startswith("---") or patch.startswith("@@"):
            # This is a diff format, parse and apply
            return self._apply_diff_format(original, patch)
        else:
            # Assume it's the new content
            return patch

    def _apply_diff_format(self, original: str, patch: str) -> str:
        """Apply unified diff format patch."""
        lines = original.split("\n")
        result_lines = lines.copy()
        offset = 0

        # Simple hunk parsing
        hunk_pattern = re.compile(r"@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@")

        current_line = 0
        in_hunk = False

        for patch_line in patch.split("\n"):
            match = hunk_pattern.match(patch_line)
            if match:
                current_line = int(match.group(1)) - 1 + offset
                in_hunk = True
            elif in_hunk:
                if patch_line.startswith("-"):
                    # Remove line
                    if current_line < len(result_lines):
                        del result_lines[current_line]
                        offset -= 1
                elif patch_line.startswith("+"):
                    # Add line
                    result_lines.insert(current_line, patch_line[1:])
                    current_line += 1
                    offset += 1
                elif patch_line.startswith(" "):
                    # Context line
                    current_line += 1
                elif not patch_line.strip():
                    in_hunk = False

        return "\n".join(result_lines)

    def _apply_hunks(self, file_path: str, hunks: List[Dict]) -> None:
        """Apply hunks to a file."""
        full_path = self.repo_path / file_path

        if not full_path.exists():
            # Create new file from additions
            content = []
            for hunk in hunks:
                for line in hunk["lines"]:
                    if line.startswith("+"):
                        content.append(line[1:])
            full_path.parent.mkdir(parents=True, exist_ok=True)
            full_path.write_text("\n".join(content))
        else:
            original = full_path.read_text()
            patched = self._apply_diff_format(original, self._reconstruct_diff(hunks))
            full_path.write_text(patched)

    def _reconstruct_diff(self, hunks: List[Dict]) -> str:
        """Reconstruct diff from parsed hunks."""
        lines = []
        for hunk in hunks:
            lines.append(hunk["header"])
            lines.extend(hunk["lines"])
        return "\n".join(lines)


class GitIntegration:
    """
    Main git integration class for attack remediation.

    Coordinates branch creation, patch application, committing,
    and PR creation for security fixes.
    """

    SECURITY_LABELS = ["security", "auto-remediation", "agent-smith"]

    def __init__(
        self,
        git_provider: GitProvider,
        patch_applicator: Optional[PatchApplicator] = None,
        repo_path: Optional[str] = None,
        default_base_branch: str = "main",
        default_reviewers: Optional[List[str]] = None,
        auto_label: bool = True,
    ):
        self.git_provider = git_provider
        self.patch_applicator = patch_applicator
        self.repo_path = repo_path
        self.default_base_branch = default_base_branch
        self.default_reviewers = default_reviewers or []
        self.auto_label = auto_label

        # Track created resources
        self._created_branches: Dict[str, BranchInfo] = {}
        self._created_prs: Dict[str, PullRequestInfo] = {}

    def _generate_branch_name(
        self,
        attack_id: str,
        attack_type: str,
    ) -> str:
        """Generate branch name for security fix."""
        # Sanitize attack type for branch name
        safe_type = re.sub(r"[^a-zA-Z0-9]", "-", attack_type.lower())
        timestamp = datetime.utcnow().strftime("%Y%m%d%H%M%S")
        return f"security/fix-{safe_type}-{attack_id[:8]}-{timestamp}"

    def _generate_commit_message(
        self,
        attack_type: str,
        attack_id: str,
        description: str,
        files_changed: List[str],
    ) -> str:
        """Generate commit message for security fix."""
        # Build commit message
        subject = f"fix(security): remediate {attack_type} vulnerability"

        body_parts = [
            "",
            f"Attack ID: {attack_id}",
            "",
            "Description:",
            description,
            "",
            "Files modified:",
        ]

        for file in files_changed:
            body_parts.append(f"  - {file}")

        body_parts.extend([
            "",
            "This fix was automatically generated by Agent Smith",
            "attack detection and remediation system.",
            "",
            "Reviewed-by: pending",
        ])

        return subject + "\n" + "\n".join(body_parts)

    def _generate_pr_title(
        self,
        attack_type: str,
        severity: str,
    ) -> str:
        """Generate PR title."""
        severity_emoji = {
            "critical": "ðŸš¨",
            "high": "ðŸ”´",
            "medium": "ðŸŸ ",
            "low": "ðŸŸ¡",
        }.get(severity.lower(), "ðŸ”µ")

        return f"{severity_emoji} [Security] Fix {attack_type} vulnerability"

    def _generate_pr_body(
        self,
        attack_id: str,
        attack_type: str,
        severity: str,
        description: str,
        affected_files: List[str],
        recommendation_id: Optional[str] = None,
        analysis_summary: Optional[str] = None,
    ) -> str:
        """Generate PR body with security details."""
        body = f"""## Security Fix

**Attack ID:** `{attack_id}`
**Type:** {attack_type}
**Severity:** {severity.upper()}
{f"**Recommendation ID:** `{recommendation_id}`" if recommendation_id else ""}

### Description

{description}

### Affected Files

"""
        for file in affected_files:
            body += f"- `{file}`\n"

        if analysis_summary:
            body += f"""
### Analysis Summary

{analysis_summary}
"""

        body += """
### Automated Remediation

This pull request was automatically generated by **Agent Smith** attack detection system.

âš ï¸ **Please review carefully before merging:**
- Verify the fix addresses the vulnerability
- Check for any unintended side effects
- Run security tests if available
- Consider additional hardening measures

### Testing

- [ ] Unit tests pass
- [ ] Security scan clean
- [ ] Manual review completed
- [ ] Regression testing done

---
*Generated by Agent Smith Auto-Remediation System*
"""
        return body

    async def create_fix_branch(
        self,
        attack_id: str,
        attack_type: str,
        base_branch: Optional[str] = None,
    ) -> BranchInfo:
        """Create a branch for a security fix."""
        branch_name = self._generate_branch_name(attack_id, attack_type)
        base = base_branch or self.default_base_branch

        logger.info(f"Creating fix branch: {branch_name} from {base}")

        branch = await self.git_provider.create_branch(branch_name, base)
        self._created_branches[attack_id] = branch

        return branch

    async def apply_and_commit_patch(
        self,
        attack_id: str,
        attack_type: str,
        patch_content: str,
        file_path: str,
        description: str,
    ) -> Tuple[PatchApplication, Optional[CommitInfo]]:
        """Apply a patch and commit the changes."""
        if not self.patch_applicator:
            raise GitOperationError("Patch applicator not configured")

        # Apply patch
        logger.info(f"Applying patch to {file_path}")
        result = self.patch_applicator.apply_patch(patch_content, file_path)

        if not result.success:
            logger.error(f"Failed to apply patch: {result.error_message}")
            return result, None

        # Get all changed files
        changed_files = (
            result.files_modified +
            result.files_created
        )

        if not changed_files:
            logger.warning("No files were changed by patch")
            return result, None

        # Generate commit message
        commit_message = self._generate_commit_message(
            attack_type=attack_type,
            attack_id=attack_id,
            description=description,
            files_changed=changed_files,
        )

        # Commit changes
        logger.info(f"Committing changes for attack {attack_id}")
        commit = await self.git_provider.commit_changes(
            message=commit_message,
            files=changed_files,
        )

        return result, commit

    async def create_security_pr(
        self,
        attack_id: str,
        attack_type: str,
        severity: str,
        description: str,
        affected_files: List[str],
        branch_name: str,
        recommendation_id: Optional[str] = None,
        analysis_summary: Optional[str] = None,
        draft: bool = True,
        additional_labels: Optional[List[str]] = None,
        additional_reviewers: Optional[List[str]] = None,
    ) -> PullRequestInfo:
        """Create a pull request for a security fix."""
        # Generate PR content
        title = self._generate_pr_title(attack_type, severity)
        body = self._generate_pr_body(
            attack_id=attack_id,
            attack_type=attack_type,
            severity=severity,
            description=description,
            affected_files=affected_files,
            recommendation_id=recommendation_id,
            analysis_summary=analysis_summary,
        )

        # Collect labels
        labels = []
        if self.auto_label:
            labels.extend(self.SECURITY_LABELS)
        if additional_labels:
            labels.extend(additional_labels)

        # Add severity label
        labels.append(f"severity:{severity.lower()}")

        # Collect reviewers
        reviewers = self.default_reviewers.copy()
        if additional_reviewers:
            reviewers.extend(additional_reviewers)

        # Push branch first
        logger.info(f"Pushing branch {branch_name}")
        push_success = await self.git_provider.push_branch(branch_name)

        if not push_success:
            raise PRCreationError(f"Failed to push branch: {branch_name}")

        # Create PR
        logger.info(f"Creating PR for attack {attack_id}")
        pr = await self.git_provider.create_pull_request(
            title=title,
            body=body,
            branch=branch_name,
            base_branch=self.default_base_branch,
            draft=draft,
            labels=labels,
            reviewers=reviewers if reviewers else None,
        )

        # Track created PR
        pr.attack_id = attack_id
        pr.recommendation_id = recommendation_id
        self._created_prs[attack_id] = pr

        logger.info(f"Created PR #{pr.number}: {pr.url}")

        return pr

    async def create_fix_pr_from_recommendation(
        self,
        attack_id: str,
        attack_type: str,
        severity: str,
        description: str,
        patch_content: str,
        file_path: str,
        recommendation_id: str,
        analysis_summary: Optional[str] = None,
        draft: bool = True,
    ) -> Tuple[PullRequestInfo, CommitInfo]:
        """
        Complete workflow: create branch, apply patch, commit, and create PR.
        """
        # Create branch
        branch = await self.create_fix_branch(
            attack_id=attack_id,
            attack_type=attack_type,
        )

        # Apply patch and commit
        patch_result, commit = await self.apply_and_commit_patch(
            attack_id=attack_id,
            attack_type=attack_type,
            patch_content=patch_content,
            file_path=file_path,
            description=description,
        )

        if not commit:
            raise GitOperationError(
                f"Failed to apply patch: {patch_result.error_message}"
            )

        # Create PR
        pr = await self.create_security_pr(
            attack_id=attack_id,
            attack_type=attack_type,
            severity=severity,
            description=description,
            affected_files=commit.files_changed,
            branch_name=branch.name,
            recommendation_id=recommendation_id,
            analysis_summary=analysis_summary,
            draft=draft,
        )

        return pr, commit

    async def get_pr_status(
        self,
        attack_id: str,
    ) -> Optional[PRStatus]:
        """Get the status of a PR created for an attack."""
        if attack_id not in self._created_prs:
            return None

        pr_info = self._created_prs[attack_id]
        updated_pr = await self.git_provider.get_pull_request(pr_info.number)

        if updated_pr:
            self._created_prs[attack_id] = updated_pr
            return updated_pr.status

        return pr_info.status

    async def update_pr_with_additional_fix(
        self,
        attack_id: str,
        patch_content: str,
        file_path: str,
        description: str,
    ) -> Optional[CommitInfo]:
        """Add additional fixes to an existing PR."""
        if attack_id not in self._created_branches:
            logger.error(f"No branch found for attack {attack_id}")
            return None

        branch = self._created_branches[attack_id]

        # Switch to branch
        await self.git_provider.switch_branch(branch.name)

        # Apply additional patch
        patch_result, commit = await self.apply_and_commit_patch(
            attack_id=attack_id,
            attack_type="additional-fix",
            patch_content=patch_content,
            file_path=file_path,
            description=f"Additional fix: {description}",
        )

        if commit:
            # Push updated branch
            await self.git_provider.push_branch(branch.name)

        return commit


# Factory functions

def create_git_integration(
    repo_path: str,
    use_mock: bool = False,
    default_base_branch: str = "main",
    default_reviewers: Optional[List[str]] = None,
) -> GitIntegration:
    """Create a git integration instance."""
    if use_mock:
        provider = MockGitProvider()
        applicator = None
    else:
        provider = LocalGitProvider(repo_path)
        applicator = PatchApplicator(repo_path)

    return GitIntegration(
        git_provider=provider,
        patch_applicator=applicator,
        repo_path=repo_path,
        default_base_branch=default_base_branch,
        default_reviewers=default_reviewers,
    )


def create_local_git_provider(
    repo_path: str,
    remote: str = "origin",
) -> LocalGitProvider:
    """Create a local git provider."""
    return LocalGitProvider(repo_path=repo_path, remote=remote)


def create_mock_git_provider() -> MockGitProvider:
    """Create a mock git provider for testing."""
    return MockGitProvider()


def create_patch_applicator(repo_path: str) -> PatchApplicator:
    """Create a patch applicator."""
    return PatchApplicator(repo_path=repo_path)
